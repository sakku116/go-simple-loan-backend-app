// Code generated by mockery v2.50.4. DO NOT EDIT.

package mocks

import (
	dto "backend/domain/dto"

	gin "github.com/gin-gonic/gin"

	mock "github.com/stretchr/testify/mock"
)

// IAuthUcase is an autogenerated mock type for the IAuthUcase type
type IAuthUcase struct {
	mock.Mock
}

// CheckToken provides a mock function with given fields: payload
func (_m *IAuthUcase) CheckToken(payload dto.CheckTokenReq) (*dto.CheckTokenRespData, error) {
	ret := _m.Called(payload)

	if len(ret) == 0 {
		panic("no return value specified for CheckToken")
	}

	var r0 *dto.CheckTokenRespData
	var r1 error
	if rf, ok := ret.Get(0).(func(dto.CheckTokenReq) (*dto.CheckTokenRespData, error)); ok {
		return rf(payload)
	}
	if rf, ok := ret.Get(0).(func(dto.CheckTokenReq) *dto.CheckTokenRespData); ok {
		r0 = rf(payload)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dto.CheckTokenRespData)
		}
	}

	if rf, ok := ret.Get(1).(func(dto.CheckTokenReq) error); ok {
		r1 = rf(payload)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Login provides a mock function with given fields: payload
func (_m *IAuthUcase) Login(payload dto.LoginReq) (*dto.LoginRespData, error) {
	ret := _m.Called(payload)

	if len(ret) == 0 {
		panic("no return value specified for Login")
	}

	var r0 *dto.LoginRespData
	var r1 error
	if rf, ok := ret.Get(0).(func(dto.LoginReq) (*dto.LoginRespData, error)); ok {
		return rf(payload)
	}
	if rf, ok := ret.Get(0).(func(dto.LoginReq) *dto.LoginRespData); ok {
		r0 = rf(payload)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dto.LoginRespData)
		}
	}

	if rf, ok := ret.Get(1).(func(dto.LoginReq) error); ok {
		r1 = rf(payload)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RefreshToken provides a mock function with given fields: payload
func (_m *IAuthUcase) RefreshToken(payload dto.RefreshTokenReq) (*dto.RefreshTokenRespData, error) {
	ret := _m.Called(payload)

	if len(ret) == 0 {
		panic("no return value specified for RefreshToken")
	}

	var r0 *dto.RefreshTokenRespData
	var r1 error
	if rf, ok := ret.Get(0).(func(dto.RefreshTokenReq) (*dto.RefreshTokenRespData, error)); ok {
		return rf(payload)
	}
	if rf, ok := ret.Get(0).(func(dto.RefreshTokenReq) *dto.RefreshTokenRespData); ok {
		r0 = rf(payload)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dto.RefreshTokenRespData)
		}
	}

	if rf, ok := ret.Get(1).(func(dto.RefreshTokenReq) error); ok {
		r1 = rf(payload)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Register provides a mock function with given fields: ctx, payload
func (_m *IAuthUcase) Register(ctx *gin.Context, payload dto.RegisterUserReq) (*dto.RegisterUserRespData, error) {
	ret := _m.Called(ctx, payload)

	if len(ret) == 0 {
		panic("no return value specified for Register")
	}

	var r0 *dto.RegisterUserRespData
	var r1 error
	if rf, ok := ret.Get(0).(func(*gin.Context, dto.RegisterUserReq) (*dto.RegisterUserRespData, error)); ok {
		return rf(ctx, payload)
	}
	if rf, ok := ret.Get(0).(func(*gin.Context, dto.RegisterUserReq) *dto.RegisterUserRespData); ok {
		r0 = rf(ctx, payload)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*dto.RegisterUserRespData)
		}
	}

	if rf, ok := ret.Get(1).(func(*gin.Context, dto.RegisterUserReq) error); ok {
		r1 = rf(ctx, payload)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewIAuthUcase creates a new instance of IAuthUcase. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIAuthUcase(t interface {
	mock.TestingT
	Cleanup(func())
}) *IAuthUcase {
	mock := &IAuthUcase{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
